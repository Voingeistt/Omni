# Omni_voice.py
# Enhanced for basic conversational interaction with STT, modified TTS, and GUI.

import os
from datetime import datetime
try:
    from kokoro import KPipeline
    import soundfile as sf
    import torch
    import speech_recognition as sr
    import numpy as np
    from playsound import playsound # Fallback for non-Windows
    import ollama
    import customtkinter as ctk
    import threading
    import queue
    import sys
    if sys.platform == "win32":
        import winsound # Preferred for Windows
    import keyboard
    import subprocess
    from PIL import Image, ImageTk
    import time
    import tkinter as tk # For basic Tkinter error dialog if CTk fails early
except ImportError as e:
    error_message = f"Error importing libraries: {e}\n" \
                    "Please ensure you have run: pip install -r Omni/requirements.txt\n" \
                    "And that all dependencies (espeak-ng, PyAudio, Ollama) are correctly installed."
    print(error_message)
    # Attempt to show a Tkinter error if possible
    try:
        root_err = tk.Tk()
        root_err.withdraw()
        tk.messagebox.showerror("Omni Startup Error", error_message)
        root_err.destroy()
    except:
        pass # Console print is the fallback
    exit(1)

# --- Global Variables ---
KOKORO_PIPELINE = None
APP_NAME = "Omni Interface"
WINDOW_SIZE = "800x650" # Increased height for waveform
KOKORO_INIT_SUCCESSFUL = None # None (pending), True (success), False (failure)
KOKORO_INIT_ERROR_MESSAGE = "Kokoro TTS failed. Check console and espeak-ng setup."

ctk.set_appearance_mode("Dark")

# --- Core Logic Functions (STT, TTS, LLM) ---
def initialize_kokoro():
    global KOKORO_PIPELINE, KOKORO_INIT_ERROR_MESSAGE
    if KOKORO_PIPELINE is None:
        print("Initializing Kokoro TTS pipeline...")
        try:
            KOKORO_PIPELINE = KPipeline(lang_code='a') # Default, consider making configurable
            print("Kokoro TTS pipeline initialized successfully.")
            return True
        except Exception as e:
            KOKORO_INIT_ERROR_MESSAGE = f"Fatal Error initializing KPipeline: {e}\n" \
                                        "This might be due to missing espeak-ng or its PATH configuration."
            print(KOKORO_INIT_ERROR_MESSAGE)
            KOKORO_PIPELINE = "error"
            return False
    return KOKORO_PIPELINE != "error"

def generate_speech(text_to_speak, base_filename="Omni_response"):
    # (Content of generate_speech function - unchanged from previous correct versions)
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S_%f")
    output_filename = f"{base_filename}_{timestamp}.wav"
    if KOKORO_PIPELINE is None or KOKORO_PIPELINE == "error":
        # This check is redundant if initialize_kokoro is called first, but safe
        print("Cannot generate speech: Kokoro TTS not ready or failed.")
        return None
    if not text_to_speak or not text_to_speak.strip():
        print("Omni: Text to speak is empty. Cannot generate speech.")
        return None
    print(f"Omni generating speech for: \"{text_to_speak[:60]}...\"")
    try:
        generator = KOKORO_PIPELINE(text_to_speak, voice='af_heart')
        all_audio_chunks = [audio_chunk for _, _, audio_chunk in generator]
        if not all_audio_chunks:
            print("No audio was generated by Kokoro. Check input text and model.")
            return None
        full_audio = np.concatenate(all_audio_chunks)
        sf.write(output_filename, full_audio, 24000) # Kokoro's default sample rate
        # print(f"Omni speech saved to {output_filename}") # Less verbose
        return output_filename
    except Exception as e:
        print(f"Error during speech generation: {e}")
        return None

def listen_for_command():
    # (Content of listen_for_command function - unchanged from previous correct versions)
    recognizer = sr.Recognizer()
    microphone = sr.Microphone()
    with microphone as source:
        print("\nCalibrating microphone...")
        try:
            recognizer.adjust_for_ambient_noise(source, duration=1)
        except Exception as e:
            print(f"Mic calibration error: {e}. Using default.")
        print("Omni is listening...")
        try:
            audio = recognizer.listen(source, timeout=5, phrase_time_limit=10)
        except sr.WaitTimeoutError:
            print("Omni: No speech detected.")
            return None, None
        except Exception as e: # Catch other listen errors
            print(f"Error during listen: {e}")
            return None, None
    try:
        print("Omni processing speech...")
        command = recognizer.recognize_google(audio)
        print(f"You said: {command}")
        return command.lower(), audio
    except sr.UnknownValueError:
        print("Omni: Sorry, I could not understand what you said.")
        return None, audio # Return audio for waveform even if not understood
    except sr.RequestError as e:
        print(f"Omni: Google Speech Recognition error; {e}")
        return None, None
    except Exception as e:
        print(f"Omni: Unexpected error in speech recognition: {e}")
        return None, None

def get_Omni_response(user_input):
    # (Content of get_Omni_response function - unchanged from previous correct versions)
    if not user_input:
        return "I didn't catch that. Could you please repeat?"
    print(f"Omni sending to Ollama: \"{user_input[:50]}...\"")
    try:
        response = ollama.chat(
            model='llama3.2', # Ensure this model is pulled in Ollama
            messages=[
                {'role': 'system', 'content': 'You are Omni, a helpful and friendly AI assistant. Respond conversationally and aim to be concise. If you cannot answer, politely say so.'},
                {'role': 'user', 'content': user_input}
            ]
        )
        llm_response = response['message']['content'].strip()
        if not llm_response:
            print("Omni: Ollama returned an empty response.")
            return "I'm not sure how to respond to that. Could you try asking differently?"
        return llm_response
    except ollama.ResponseError as e:
        error_detail = str(e.error) if hasattr(e, 'error') else str(e)
        print(f"Omni: Error communicating with Ollama: {error_detail}")
        if "model not found" in error_detail.lower():
            return "Language model not found. Please ensure 'llama3.2' is pulled in Ollama."
        return "Sorry, I'm having trouble thinking of a response. Check Ollama connection."
    except Exception as e:
        print(f"Omni: Unexpected error getting LLM response: {e}")
        return "An unexpected error occurred while generating a response."

# --- GUI Class (Now a CTkFrame) ---
class OmniGUI(ctk.CTkFrame):
    def __init__(self, master, kokoro_ready, **kwargs):
        super().__init__(master, **kwargs)
        self.master = master
        self.kokoro_initialized = kokoro_ready # Set based on splash screen init
        self.is_listening = False
        self.response_queue = queue.Queue()

        self.pack(fill="both", expand=True)
        self._create_widgets()
        
        self.after(100, self.process_queue)
        self.setup_hotkeys()
        self.post_kokoro_init_ui_setup() # Initial UI state based on Kokoro

    def _create_widgets(self):
        self.title_label = ctk.CTkLabel(self, text="Omni", font=ctk.CTkFont(size=30, weight="bold"))
        self.title_label.pack(pady=(10, 20))

        self.status_display_frame = ctk.CTkFrame(self, corner_radius=5)
        self.status_display_frame.pack(pady=10, padx=10, fill="x")
        ctk.CTkLabel(self.status_display_frame, text="Status:", font=ctk.CTkFont(size=16, weight="bold"), anchor="w").pack(side="left", padx=(10,5), pady=5)
        self.status_label = ctk.CTkLabel(self.status_display_frame, text="Initializing...", font=ctk.CTkFont(size=14), anchor="w")
        self.status_label.pack(side="left", padx=(0,10), pady=5, fill="x", expand=True)

        self.conversation_log = ctk.CTkTextbox(self, height=200, font=ctk.CTkFont(size=12), wrap="word", activate_scrollbars=True, corner_radius=5)
        self.conversation_log.pack(pady=10, padx=10, fill="both", expand=True)
        self.conversation_log.configure(state="disabled")

        self.waveform_frame = ctk.CTkFrame(self, height=100, corner_radius=5)
        self.waveform_frame.pack(pady=10, padx=10, fill="x")
        self.waveform_frame.grid_propagate(False)
        canvas_bg_color = self.cget("fg_color")[1] if isinstance(self.cget("fg_color"), tuple) else "#2B2B2B"
        self.waveform_canvas = tk.Canvas(self.waveform_frame, bg=canvas_bg_color, bd=0, highlightthickness=0)
        self.waveform_canvas.pack(fill="both", expand=True, padx=1, pady=1)

        self.controls_frame = ctk.CTkFrame(self, corner_radius=0, fg_color="transparent")
        self.controls_frame.pack(pady=(10,20), padx=10, fill="x")
        self.controls_frame.grid_columnconfigure((0, 1), weight=1)

        self.listen_button = ctk.CTkButton(self.controls_frame, text="ðŸŽ™ï¸ Start Listening", font=ctk.CTkFont(size=16, weight="bold"), command=self.toggle_listening, height=50, corner_radius=8, state="disabled")
        self.listen_button.grid(row=0, column=0, padx=(0,5), pady=5, sticky="ew")

        self.exit_button = ctk.CTkButton(self.controls_frame, text="ðŸšª Exit", font=ctk.CTkFont(size=16, weight="bold"), command=self.on_closing, height=50, fg_color="#D32F2F", hover_color="#B71C1C", corner_radius=8)
        self.exit_button.grid(row=0, column=1, padx=(5,0), pady=5, sticky="ew")

    def post_kokoro_init_ui_setup(self):
        if self.kokoro_initialized:
            self.update_status("Kokoro TTS Initialized. Ready.")
            self.add_to_log("System: Kokoro TTS Initialized. Ready.")
            self.listen_button.configure(state="normal")
            self.clear_waveform("Ready. Press Ctrl+J or 'Start Listening'.")
        else:
            self.update_status(f"ERROR: {KOKORO_INIT_ERROR_MESSAGE}")
            self.add_to_log(f"System: ERROR - {KOKORO_INIT_ERROR_MESSAGE}", "Error")
            self.listen_button.configure(state="disabled")
            self.clear_waveform("TTS System Error.")

    def setup_hotkeys(self):
        try:
            keyboard.add_hotkey('ctrl+j', self.on_hotkey_press, suppress=False) # suppress=False might be needed
            self.add_to_log("System: Ctrl+J hotkey registered.", "System")
            print("System: Ctrl+J hotkey registered.")
        except Exception as e:
            error_msg = f"Failed to register Ctrl+J hotkey: {e}. Try running as administrator."
            self.add_to_log(error_msg, "Error")
            print(f"Error: {error_msg}")
            self.update_status(f"Hotkey Error: {e}")

    def on_hotkey_press(self):
        print("Ctrl+J hotkey pressed!")
        # Ensure toggle_listening is called in the main thread context if hotkey lib uses own thread
        self.master.after(0, self.toggle_listening)


    def update_status(self, message):
        self.status_label.configure(text=message)
        print(f"GUI Status: {message}")

    def add_to_log(self, message, sender="System"):
        self.conversation_log.configure(state="normal")
        self.conversation_log.insert("end", f"[{sender.upper()}]: {message}\n")
        self.conversation_log.see("end")
        self.conversation_log.configure(state="disabled")

    def toggle_listening(self):
        if not self.kokoro_initialized:
            self.update_status("Cannot listen: Kokoro TTS not ready.")
            self.add_to_log("System: Attempted to listen but TTS not ready.", "Error")
            return
        if self.is_listening:
            self.is_listening = False
            self.listen_button.configure(text="ðŸŽ™ï¸ Start Listening", fg_color=ctk.ThemeManager.theme["CTkButton"]["fg_color"], state="normal")
            self.update_status("Continuous listening stopped.")
            self.add_to_log("System: Continuous listening stopped.")
            self.response_queue.put(("clear_waveform", "Listening stopped."))
        else:
            self.is_listening = True
            self.listen_button.configure(text="ðŸ›‘ Stop Listening", fg_color="orange", state="normal")
            self.update_status("Continuous listening activated...")
            self.add_to_log("System: Continuous listening mode activated.")
            self.clear_waveform("Listening...")
            threading.Thread(target=self.continuous_listen_loop, daemon=True).start()

    def continuous_listen_loop(self):
        # (Content of continuous_listen_loop - largely unchanged, ensure it uses response_queue correctly)
        while self.is_listening:
            # self.response_queue.put(("status", "Listening for your command...")) # Status set by toggle_listening
            # self.response_queue.put(("log", ("System: Listening...", "System"))) # Log set by toggle_listening
            user_input, audio_data = listen_for_command()

            if not self.is_listening: # Loop might have been stopped while listening
                self.response_queue.put(("listening_done", None)) # Ensure UI updates
                break
            
            if audio_data: self.response_queue.put(("waveform_data", audio_data))
            else: self.response_queue.put(("clear_waveform", "No audio detected."))

            if user_input:
                self.response_queue.put(("log", (f"You said: {user_input}", "User")))
                self.response_queue.put(("status", f"Processing: \"{user_input[:30]}...\""))

                if user_input in ["exit", "quit", "goodbye Omni", "Omni shutdown"]:
                    self.response_queue.put(("log", ("System: Shutdown sequence initiated.", "System")))
                    self.response_queue.put(("status", "Shutting down..."))
                    self.speak_and_play_gui("Goodbye! Shutting down.", "Omni_farewell")
                    self.response_queue.put(("close_app", None)) # Signal main thread to close
                    self.is_listening = False # Stop this loop
                    break 
                elif "Omni open chrome" in user_input or "open chrome browser" in user_input:
                    self.response_queue.put(("log", ("Opening Google Chrome...", "System")))
                    self.response_queue.put(("status", "Opening Google Chrome..."))
                    self.speak_and_play_gui("Certainly, opening Google Chrome.")
                    try:
                        if sys.platform == "win32": subprocess.Popen(["start", "chrome"], shell=True)
                        elif sys.platform == "darwin": subprocess.Popen(["open", "-a", "Google Chrome"])
                        else:
                            launched = False
                            for cmd_name in ["google-chrome", "google-chrome-stable", "chromium-browser", "chromium"]:
                                try: subprocess.Popen([cmd_name]); launched = True; break
                                except FileNotFoundError: continue
                            if not launched:
                                self.response_queue.put(("log", ("Could not find Chrome executable.", "Error")))
                                self.speak_and_play_gui("I couldn't find Google Chrome on your system.")
                    except Exception as e:
                        self.response_queue.put(("log", (f"Failed to open Chrome: {e}", "Error")))
                        self.speak_and_play_gui(f"Sorry, an error occurred opening Chrome: {e}")
                elif user_input.startswith("Omni type") or user_input.startswith("type this"):
                    text_to_type = ""
                    if user_input.startswith("Omni type "): text_to_type = user_input[len("Omni type "):].strip()
                    elif user_input.startswith("type this "): text_to_type = user_input[len("type this "):].strip()
                    elif user_input.startswith("type "): text_to_type = user_input[len("type "):].strip()
                    
                    if text_to_type:
                        self.response_queue.put(("log", (f"Typing: \"{text_to_type}\"", "System")))
                        self.response_queue.put(("status", f"Typing: \"{text_to_type[:30]}...\""))
                        try:
                            time.sleep(0.5) 
                            keyboard.write(text_to_type)
                            self.response_queue.put(("log", ("Typing complete.", "System")))
                        except Exception as e:
                            self.response_queue.put(("log", (f"Failed to type: {e}", "Error")))
                            self.speak_and_play_gui(f"Sorry, an error occurred while typing: {e}")
                    else:
                        self.response_queue.put(("log", ("No text specified for typing.", "System")))
                        self.speak_and_play_gui("What would you like me to type?")
                else: # Default to LLM response
                    response_text = get_Omni_response(user_input)
                    self.response_queue.put(("log", (response_text, "Omni")))
                    self.response_queue.put(("status", "Speaking response..."))
                    self.speak_and_play_gui(response_text)
                
                if not self.is_listening: break # Check again if stop was signaled during processing
            else: # No user input from listen_for_command
                self.response_queue.put(("log", ("No command detected or STT error. Listening again.", "System")))
                self.response_queue.put(("status", "No command detected. Listening again..."))
                self.response_queue.put(("clear_waveform", "Listening...")) # Keep waveform clear
        
        # Loop ended
        if not self.is_listening: # If loop exited because is_listening became false
             self.response_queue.put(("listening_done", None)) # Ensure UI updates to non-listening state
        print("Continuous listening loop ended.")


    def speak_and_play_gui(self, text, base_filename="Omni_response_gui"):
        # (Content of speak_and_play_gui - unchanged from previous correct versions, including winsound/playsound logic and file deletion)
        if not self.kokoro_initialized or KOKORO_PIPELINE == "error":
            self.response_queue.put(("log", ("Cannot speak: Kokoro TTS not ready or failed.", "Error")))
            self.response_queue.put(("status", "Error: TTS not available."))
            return
        output_audio_file = generate_speech(text, base_filename=base_filename)
        if output_audio_file:
            # self.response_queue.put(("log", (f"Audio saved: {os.path.basename(output_audio_file)}", "System"))) # Less verbose
            try:
                if sys.platform == "win32":
                    winsound.PlaySound(output_audio_file, winsound.SND_FILENAME)
                    winsound.PlaySound(None, winsound.SND_PURGE) 
                else:
                    playsound(output_audio_file)
                self.response_queue.put(("log", ("Playback complete.", "System")))
            except Exception as e:
                self.response_queue.put(("log", (f"Error playing sound: {str(e)}", "Error")))
                self.response_queue.put(("status", f"Error playing sound: {str(e)}"))
            
            deleted = False
            for i in range(5): # Retry deletion
                try:
                    time.sleep(0.1 * (i + 1)) # Shorter, increasing delay
                    os.remove(output_audio_file)
                    # self.response_queue.put(("log", (f"Cleaned up: {os.path.basename(output_audio_file)}", "System"))) # Less verbose
                    deleted = True; break
                except PermissionError:
                    if i == 4: self.response_queue.put(("log", (f"Error deleting audio file {os.path.basename(output_audio_file)} after retries.", "Error")))
                    # else: self.response_queue.put(("log", (f"Deletion attempt {i+1} failed for {os.path.basename(output_audio_file)}, retrying...", "System")))
                except Exception as e:
                    self.response_queue.put(("log", (f"Unexpected error deleting audio file: {str(e)}", "Error"))); break
            if not deleted and os.path.exists(output_audio_file):
                 self.response_queue.put(("log", (f"Could not delete {os.path.basename(output_audio_file)}. It might be in use.", "Warning")))
        else:
            self.response_queue.put(("log", ("Failed to generate speech audio.", "Error")))
            self.response_queue.put(("status", "Error: Failed to generate speech."))


    def process_queue(self):
        # (Content of process_queue - largely unchanged, ensure it handles all message types)
        try:
            while True: # Process all available messages
                message_type, data = self.response_queue.get_nowait()
                if message_type == "status": self.update_status(data)
                elif message_type == "log":
                    msg, sender = data if isinstance(data, tuple) and len(data) == 2 else (data, "System")
                    self.add_to_log(msg, sender)
                elif message_type == "enable_listen": # This might be redundant if post_kokoro_init_ui_setup handles it
                    if self.kokoro_initialized: self.listen_button.configure(state="normal")
                elif message_type == "listening_done": # Called when continuous_listen_loop ends due to self.is_listening=False
                    self.is_listening = False # Ensure state consistency
                    self.listen_button.configure(text="ðŸŽ™ï¸ Start Listening", state="normal", fg_color=ctk.ThemeManager.theme["CTkButton"]["fg_color"])
                    self.update_status("Ready for next command.")
                    self.clear_waveform("Ready.")
                elif message_type == "close_app": self.on_closing() # Triggered by voice command "exit" etc.
                elif message_type == "waveform_data":
                    if data: self.draw_waveform(data)
                elif message_type == "clear_waveform":
                    self.clear_waveform(data if isinstance(data, str) else "Listening...")
        except queue.Empty: pass
        finally: self.after(100, self.process_queue) # Schedule next check

    def draw_waveform(self, audio_data: sr.AudioData):
        # (Content of draw_waveform - unchanged from previous correct versions)
        self.waveform_canvas.delete("all")
        raw_data, sample_width = audio_data.frame_data, audio_data.sample_width
        dtype_map = {1: np.int8, 2: np.int16, 4: np.int32}
        if sample_width not in dtype_map:
            self.clear_waveform(f"Unsupported audio sample width: {sample_width}"); return
        try: samples = np.frombuffer(raw_data, dtype=dtype_map[sample_width])
        except Exception as e: self.clear_waveform(f"Error processing audio data: {e}"); return
        if len(samples) == 0: self.clear_waveform("Empty audio data for waveform."); return
        
        max_abs_val = np.max(np.abs(samples)) if len(samples) > 0 else 1.0
        normalized_samples = samples / max_abs_val if max_abs_val > 0 else samples.astype(float) # Avoid division by zero
        
        canvas_width = self.waveform_canvas.winfo_width()
        canvas_height = self.waveform_canvas.winfo_height()
        if canvas_width <= 1 or canvas_height <= 1: # Canvas not ready
            self.after(50, lambda ad=audio_data: self.draw_waveform(ad)); return # Retry

        num_points_to_draw = canvas_width
        if len(normalized_samples) > num_points_to_draw:
            step = max(1, len(normalized_samples) // num_points_to_draw)
            plot_samples = normalized_samples[::step][:num_points_to_draw]
        else:
            plot_samples = normalized_samples
        
        num_points_to_draw = len(plot_samples)
        if num_points_to_draw < 2: 
            self.clear_waveform("Not enough data points for waveform."); return

        y_offset = canvas_height / 2
        y_amplitude = (canvas_height / 2) * 0.85 # Use 85% of half-height
        
        # Create a list of (x, y) coordinates
        points = []
        for i, sample_value in enumerate(plot_samples):
            x = (i / (num_points_to_draw - 1)) * canvas_width if num_points_to_draw > 1 else canvas_width / 2
            y = y_offset - (sample_value * y_amplitude)
            points.extend([x, y])
        
        self.waveform_canvas.create_line(points, fill="#00BCD4", width=1.5) # Sci-fi cyan
        self.waveform_canvas.create_line(0, y_offset, canvas_width, y_offset, fill="#555555", width=0.5) # Center line

    def clear_waveform(self, message="Listening..."):
        # (Content of clear_waveform - unchanged from previous correct versions)
        self.waveform_canvas.delete("all")
        try:
            self.waveform_canvas.update_idletasks() # Ensure dimensions are current
            width = self.waveform_canvas.winfo_width()
            height = self.waveform_canvas.winfo_height()
            anchor_pos_x = width / 2 if width > 1 else 10
            anchor_pos_y = height / 2 if height > 1 else 10
            anchor_type = "center" if width > 1 and height > 1 else "nw"
            self.waveform_canvas.create_text(anchor_pos_x, anchor_pos_y, text=message, anchor=anchor_type, fill="gray", font=("Arial", 10))
        except tk.TclError: # If canvas is destroyed or not ready
             self.waveform_canvas.create_text(10, 10, text=message, anchor="nw", fill="gray", font=("Arial", 10))


    def on_closing(self):
        print("Omni GUI is closing.")
        try: keyboard.remove_hotkey('ctrl+j'); print("System: Ctrl+J hotkey unregistered.")
        except Exception as e: print(f"Note: Could not unregister hotkey: {e}")
        self.is_listening = False # Stop any listening loops
        if hasattr(self.master, 'quit') and callable(self.master.quit):
            self.master.quit()
        if hasattr(self.master, 'destroy') and callable(self.master.destroy):
            self.master.destroy()
        sys.exit(0)

# --- Splash Screen and Main Application Logic ---
if __name__ == "__main__":
    # 1. Initial Dependency Check (Basic Tkinter for error reporting if CTk fails)
    try:
        if not hasattr(ctk, "CTkFrame"): raise ImportError("CustomTkinter seems not fully available.")
        Image.new("RGB", (1,1)) # Basic Pillow check
    except Exception as e:
        critical_error_message = f"Critical Dependency Missing:\n{e}\n\nPlease install all requirements from Omni/requirements.txt.\nApplication will exit."
        print(critical_error_message)
        try:
            err_root = tk.Tk()
            err_root.withdraw() # Hide the main window of this temporary root
            tk.messagebox.showerror("Omni Startup Error", critical_error_message, parent=None)
            err_root.destroy()
        except Exception as tk_e:
            print(f"Could not display Tkinter error dialog: {tk_e}")
        sys.exit(1)

    # 2. Create the main application root window (hidden initially)
    root = ctk.CTk()
    root.title(APP_NAME)
    root.geometry(WINDOW_SIZE)
    root.withdraw() 

    splash_screen_window = None

    # 3. Kokoro Initialization Thread
    def run_kokoro_initialization_thread():
        global KOKORO_INIT_SUCCESSFUL # Modifies global
        # initialize_kokoro() already prints its status and sets KOKORO_PIPELINE and KOKORO_INIT_ERROR_MESSAGE
        KOKORO_INIT_SUCCESSFUL = initialize_kokoro()

    # 4. Function to check Kokoro status and transition
    def check_kokoro_status_and_launch_main_app():
        global splash_screen_window, root, KOKORO_INIT_SUCCESSFUL
        
        if KOKORO_INIT_SUCCESSFUL is None: # Still initializing
            if root.winfo_exists(): # Ensure root is still there for .after
                root.after(100, check_kokoro_status_and_launch_main_app)
            return

        if splash_screen_window and splash_screen_window.winfo_exists():
            splash_screen_window.destroy()
            splash_screen_window = None

        if KOKORO_INIT_SUCCESSFUL:
            app_frame = OmniGUI(master=root, kokoro_ready=True)
            # app_frame.post_kokoro_init_ui_setup() # Called from OmniGUI.__init__ via kokoro_ready
            root.deiconify() # Show the main root window
        else:
            # Kokoro failed. Show error in a new Toplevel of the (still hidden) root.
            root.withdraw() # Ensure root is hidden
            error_dialog = ctk.CTkToplevel(root)
            error_dialog.title("Omni Initialization Error")
            error_message_full = f"FATAL ERROR:\n{KOKORO_INIT_ERROR_MESSAGE}\n\nApplication will exit."
            ctk.CTkLabel(error_dialog, text=error_message_full, font=("Arial", 14), wraplength=380, justify="left").pack(pady=20, padx=20)
            
            def quit_app_on_error_dialog():
                error_dialog.destroy()
                root.quit()
                root.destroy()
                sys.exit(1)
            ctk.CTkButton(error_dialog, text="OK", command=quit_app_on_error_dialog, width=100).pack(pady=10)
            
            error_dialog.update_idletasks()
            ew, eh = 400, 220 # Adjusted height for potentially longer error
            sx = (error_dialog.winfo_screenwidth() // 2) - (ew // 2)
            sy = (error_dialog.winfo_screenheight() // 2) - (eh // 2)
            error_dialog.geometry(f"{ew}x{eh}+{sx}+{sy}")
            error_dialog.lift()
            error_dialog.attributes("-topmost", True)
            # The root.mainloop() will handle this dialog until quit_app_on_error_dialog is called.
            # If user closes error dialog via window manager, on_closing of root should handle exit.

    # 5. Function to display splash screen
    def display_splash_screen():
        global splash_screen_window, root

        splash_screen_window = ctk.CTkToplevel(root) # Parent is the hidden root
        splash_screen_window.overrideredirect(True) # Frameless
        
        img_path = "Omni.png" 
        splash_width, splash_height = 300, 150 
        try:
            if not os.path.exists(img_path): raise FileNotFoundError(f"Splash image not found: {img_path}")
            pil_image = Image.open(img_path)
            max_splash_width, max_splash_height = 400, 300
            pil_image.thumbnail((max_splash_width, max_splash_height), Image.Resampling.LANCZOS)
            ctk_image = ImageTk.PhotoImage(pil_image)
            img_label = ctk.CTkLabel(splash_screen_window, image=ctk_image, text="")
            img_label.image = ctk_image 
            img_label.pack(pady=20, padx=20)
            splash_width, splash_height = pil_image.width + 40, pil_image.height + 80 
        except Exception as e:
            ctk.CTkLabel(splash_screen_window, text="Omni", font=ctk.CTkFont(size=40, weight="bold")).pack(pady=20, padx=50)
            print(f"Splash image error: {e}. Displaying text.")

        ctk.CTkLabel(splash_screen_window, text="Initializing Systems...", font=ctk.CTkFont(size=14)).pack(pady=(0, 20))
        
        splash_screen_window.update_idletasks() # Needed to get correct screen width/height
        screen_width = splash_screen_window.winfo_screenwidth()
        screen_height = splash_screen_window.winfo_screenheight()
        x_pos = (screen_width // 2) - (splash_width // 2)
        y_pos = (screen_height // 2) - (splash_height // 2)
        splash_screen_window.geometry(f"{splash_width}x{splash_height}+{x_pos}+{y_pos}")
        
        splash_screen_window.lift()
        splash_screen_window.attributes("-topmost", True)
        # splash_screen_window.update_idletasks() # Already called

        # Start Kokoro initialization in a separate thread
        init_thread = threading.Thread(target=run_kokoro_initialization_thread, daemon=True)
        init_thread.start()

        # Schedule the first check for Kokoro init completion using the root's event loop
        root.after(100, check_kokoro_status_and_launch_main_app)
        
    # 6. Start the process
    display_splash_screen()
    root.mainloop() # Single mainloop for the entire application.